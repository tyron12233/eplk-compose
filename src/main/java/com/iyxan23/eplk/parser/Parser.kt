package com.iyxan23.eplk.parser

import com.iyxan23.eplk.Tokens
import com.iyxan23.eplk.errors.EplkRuntimeError
import com.iyxan23.eplk.errors.SyntaxError
import com.iyxan23.eplk.interpreter.RealtimeResult
import com.iyxan23.eplk.interpreter.Scope
import com.iyxan23.eplk.lexer.models.Position
import com.iyxan23.eplk.lexer.models.Token
import com.iyxan23.eplk.nodes.*
import com.iyxan23.eplk.nodes.control.*
import com.iyxan23.eplk.nodes.operation.BinOpNode
import com.iyxan23.eplk.nodes.operation.UnaryOpNode
import com.iyxan23.eplk.nodes.types.*
import com.iyxan23.eplk.nodes.variable.VarAccessNode
import com.iyxan23.eplk.nodes.variable.VarAssignNode
import com.iyxan23.eplk.nodes.variable.VarDeclarationNode
import com.iyxan23.eplk.objects.EplkObject
import com.iyxan23.eplk.nodes.compose.ComposeFunctionDefinitionNode
import com.iyxan23.eplk.nodes.types.NullNode
import com.iyxan23.eplk.nodes.variable.LambdaNode
import com.iyxan23.eplk.nodes.variable.ParameterListNode
import com.iyxan23.eplk.nodes.variable.ParameterNode

/**
 * This class parses a list of tokens generated by the lexer into an AST (Abstract Syntax Tree)
 *
 * @see parse
 */
class Parser(private val tokens: ArrayList<Token>) {

    private var currentToken: Token = tokens[0]
    private var indexToken = 0

    fun parse(): ParseResult {
        val result = statements()

        // Check if we're not at the end of the file
        if (!result.hasError && currentToken.token != Tokens.EOF) {
            // Looks like theres some code after this, but those code doesn't get parsed for some reason
            // there must be a syntax error
            result.failure(
                SyntaxError(
                    "Expected '+', '-', '*', or '/'",
                    currentToken.startPosition,
                    currentToken.endPosition,
                )
            )
        }

        return result
    }

    private fun advance(): Token {
        indexToken++

        return fetchToken()
    }

    private fun reverse(amount: Int): Token {
        indexToken -= amount

        return fetchToken()
    }

    private fun fetchToken(): Token {
        if (indexToken < tokens.size && indexToken >= 0) {
            currentToken = tokens[indexToken]
        }

        return currentToken
    }

    // func-definition         = FUN IDENTIFIER PAREN_OPEN parameter-list PAREN_CLOSE NEWLINE* [[ARROW expression] | BRACES_OPEN statements BRACES_CLOSE]
    private fun funcDefinition(): ParseResult {
        val result = ParseResult()

        val startPosition = currentToken.startPosition.copy()

        if (currentToken.token != Tokens.FUN) {
            return result.failure(
                SyntaxError(
                    "Expected 'fun'",
                    currentToken.startPosition,
                    currentToken.endPosition
                )
            )
        }

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        if (currentToken.token != Tokens.IDENTIFIER) {
            return result.failure(
                SyntaxError(
                    "Expected an identifier after 'fun'",
                    currentToken.startPosition,
                    currentToken.endPosition
                )
            )
        }

        val functionName = currentToken.value!!

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        if (currentToken.token != Tokens.PAREN_OPEN) {
            return result.failure(
                SyntaxError(
                    "Expected an open parentheses '(' after identifier",
                    currentToken.startPosition,
                    currentToken.endPosition
                )
            )
        }

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        // Parse parameters
        val parametersResult = result.register(parameterList())
        if (result.hasError) return result

        val parametersNode = parametersResult as ParameterListNode



        if (currentToken.token != Tokens.PAREN_CLOSE) {
            return result.failure(
                SyntaxError(
                    "Expected a close parentheses ')' after parameters / an open parentheses",
                    currentToken.startPosition,
                    currentToken.endPosition,
                )
            )
        }

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        // Skip every newlines here
        while (currentToken.token == Tokens.NEWLINE) {
            result.registerAdvancement()
            advance()
        }

        if (currentToken.token == Tokens.ARROW) {
            // Single expression function

            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            val expressionResult = result.register(expression())
            if (result.hasError) return result

            val expression = expressionResult as Node

            return result.success(
                FunctionDefinitionNode(
                    functionName,
                    parametersNode,
                    StatementsNode(arrayOf(expression)),
                    startPosition
                )
            )

        } else if (currentToken.token == Tokens.BRACES_OPEN) {
            // Multi-line function

            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            // skip new lines
            while (currentToken.token == Tokens.NEWLINE) {
                result.registerAdvancement()
                advance()
            }

            // is this closing bracket?
            if (currentToken.token == Tokens.BRACES_CLOSE) {
                // ===========================================================
                result.registerAdvancement()
                advance()
                // ===========================================================

                return result.success(
                    FunctionDefinitionNode(
                        functionName,
                        parametersNode,
                        StatementsNode(arrayOf()),
                        startPosition,
                        currentToken.endPosition
                    )
                )
            }

            val statementsResult = result.register(statements())
            if (result.hasError) return result

            val statements = statementsResult as StatementsNode

            // Check for }
            if (currentToken.token != Tokens.BRACES_CLOSE) {
                return result.failure(
                    SyntaxError(
                        "Expected braces close '}' after statements",
                        currentToken.startPosition,
                        currentToken.endPosition
                    )
                )
            }

            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            return result.success(
                FunctionDefinitionNode(
                    functionName,
                    parametersNode,
                    statements,
                    startPosition
                )
            )
        }

        return result.failure(
            SyntaxError(
                "Expected an arrow '->' or an open brace '{' after a function definition",
                currentToken.startPosition,
                currentToken.endPosition,
            )
        )
    }

    private fun parameterList(): ParseResult {
        val result = ParseResult()

        val parameters = mutableListOf<ParameterNode>()

        if (currentToken.token == Tokens.IDENTIFIER) {



            val firstParameter = result.register(parameter())
            if (result.hasError) return result

            parameters.add(firstParameter as ParameterNode)

            while (currentToken.token == Tokens.COMMA) {
                // ===========================================================
                result.registerAdvancement()
                advance()
                // ===========================================================

                if (currentToken.token != Tokens.IDENTIFIER) {
                    return result.failure(
                        SyntaxError(
                            "Expected an identifier after a comma",
                            currentToken.startPosition,
                            currentToken.endPosition,
                        )
                    )
                }

                val parameter = result.register(parameter())
                if (result.hasError) return result

                parameters.add(parameter as ParameterNode)

            }
        }

        return result.success(
            ParameterListNode(
                parameters,
                currentToken.startPosition,
                currentToken.endPosition
            )
        )
    }

    private fun parameter(): ParseResult {
        val result = ParseResult()

        var currentParameterName: String = currentToken.value!!

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        var defaultValue: Node? = null

        // parse default value
        if (currentToken.token == Tokens.EQUAL) {
            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            val defaultValueResult = result.register(expression())
            if (result.hasError) return result

            defaultValue = defaultValueResult as Node
        }


        return result.success(ParameterNode(currentParameterName, defaultValue, currentToken.startPosition, currentToken.endPosition))
    }

    // while-expression = WHILE PAREN_OPEN expression PAREN_CLOSE expression
    private fun whileExpression(): ParseResult {
        val result = ParseResult()

        val startPosition = currentToken.startPosition.copy()

        if (currentToken.token != Tokens.WHILE) {
            return result.failure(
                SyntaxError(
                    "Expected 'while'",
                    currentToken.startPosition,
                    currentToken.endPosition
                )
            )
        }

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        if (currentToken.token != Tokens.PAREN_OPEN) {
            return result.failure(
                SyntaxError(
                    "Expected an open parentheses '(' after 'while'",
                    currentToken.startPosition,
                    currentToken.endPosition,
                )
            )
        }

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        val conditionResult = result.register(expression())
        if (result.hasError) return result

        val condition = conditionResult as Node

        if (currentToken.token != Tokens.PAREN_CLOSE) {
            return result.failure(
                SyntaxError(
                    "Expected a close parentheses ')' after an expression",
                    currentToken.startPosition,
                    currentToken.endPosition,
                )
            )
        }

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        // Check if there is an open braces '{'
        if (currentToken.token == Tokens.BRACES_OPEN) {
            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            // Alright parse the statements
            val statementsResult = result.register(statements())
            if (result.hasError) return result

            val statements = statementsResult as StatementsNode

            // Now check if there is a close brace '}'
            if (currentToken.token != Tokens.BRACES_CLOSE) {
                return result.failure(
                    SyntaxError(
                        "Expected a close brace '}' after statements",
                        currentToken.startPosition,
                        currentToken.endPosition,
                    )
                )
            }

            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            // Alright we're done!
            return result.success(
                WhileNode(
                    condition,
                    statements,
                    startPosition
                )
            )

        } else {
            // If no open brace, then this is a single expression while loop
            val expressionResult = result.register(expression())
            if (result.hasError) return result

            val expression = expressionResult as Node

            return result.success(
                WhileNode(
                    condition,
                    StatementsNode(arrayOf(expression)),
                    startPosition
                )
            )
        }
    }

    // for-expression = FOR PAREN_OPEN expression1 SEMICOLON expression2 SEMICOLON expression3 PAREN_CLOSE [[BRACES_OPEN statements BRACES_CLOSE] | expression]
    private fun forExpression(): ParseResult {
        val result = ParseResult()

        val startPosition = currentToken.startPosition.copy()
        if (currentToken.token != Tokens.FOR) {
            return result.failure(
                SyntaxError(
                    "Expected 'for'",
                    currentToken.startPosition,
                    currentToken.endPosition
                )
            )
        }

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        if (currentToken.token != Tokens.PAREN_OPEN) {
            return result.failure(
                SyntaxError(
                    "Expected an open parentheses '(' after 'for'",
                    currentToken.startPosition,
                    currentToken.endPosition,
                )
            )
        }

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        val firstExpressionResult = result.register(expression())
        if (result.hasError) return result

        val firstExpression = firstExpressionResult as Node

        if (currentToken.token != Tokens.SEMICOLON) {
            return result.failure(
                SyntaxError(
                    "Expected a semicolon after the first for loop expression",
                    currentToken.startPosition,
                    currentToken.endPosition,
                )
            )
        }

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        val secondExpressionResult = result.register(expression())
        if (result.hasError) return result

        val secondExpression = secondExpressionResult as Node

        if (currentToken.token != Tokens.SEMICOLON) {
            return result.failure(
                SyntaxError(
                    "Expected a semicolon after the second for loop expression",
                    currentToken.startPosition,
                    currentToken.endPosition,
                )
            )
        }

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        val thirdExpressionResult = result.register(expression())
        if (result.hasError) return result

        val thirdExpression = thirdExpressionResult as Node

        if (currentToken.token != Tokens.PAREN_CLOSE) {
            return result.failure(
                SyntaxError(
                    "Expected a close parentheses ')' after the third for loop expression",
                    currentToken.startPosition,
                    currentToken.endPosition,
                )
            )
        }

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        // Check if this is a multiline or a single expression for loop
        if (currentToken.token == Tokens.BRACES_OPEN) {
            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            // Multiline for loop
            val statementsResult = result.register(statements())
            if (result.hasError) return result

            val statements = statementsResult as StatementsNode

            if (currentToken.token != Tokens.BRACES_CLOSE) {
                return result.failure(
                    SyntaxError(
                        "Expected a close braces '}' after statements",
                        currentToken.startPosition,
                        currentToken.endPosition
                    )
                )
            }

            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            return result.success(
                ForNode(
                    startPosition,
                    firstExpression,
                    secondExpression,
                    thirdExpression,
                    statements
                )
            )

        } else {
            // Single expression for loop
            val expressionResult = result.register(expression())
            if (result.hasError) return result

            val expression = expressionResult as Node

            return result.success(
                ForNode(
                    startPosition,
                    firstExpression,
                    secondExpression,
                    thirdExpression,
                    StatementsNode(arrayOf(expression))
                )
            )
        }
    }

    // if-expression = IF PAREN_OPEN expression PAREN_CLOSE [[BRACES_OPEN statements BRACES_CLOSE elif-expression* else-expression*] | [statement elif-expression* else-expression]]
    private fun ifExpression(): ParseResult {
        val result = ParseResult()

        val startPosition = currentToken.startPosition.copy()
        val statements = ArrayList<Node>()
        var isSingleLine = false

        //////////////////////////////////////////////////////////////
        // IF STATEMENT
        //////////////////////////////////////////////////////////////

        if (currentToken.token != Tokens.IF) {
            return result.failure(
                SyntaxError(
                    "Expected an integer literal, float literal, identifier, 'if', 'true', 'false', '+', '-', or '('",
                    currentToken.startPosition,
                    currentToken.endPosition,
                )
            )
        }

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        if (currentToken.token != Tokens.PAREN_OPEN) {
            return result.failure(
                SyntaxError(
                    "Expected an open parentheses '(' after 'if'",
                    currentToken.startPosition,
                    currentToken.endPosition,
                )
            )
        }

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        // Parse the condition
        val conditionExpressionResult = result.register(expression())
        if (result.hasError) return result

        val conditionExpression = conditionExpressionResult as Node

        if (currentToken.token != Tokens.PAREN_CLOSE) {
            return result.failure(
                SyntaxError(
                    "Expected a close parentheses ')' after an expression",
                    currentToken.startPosition,
                    currentToken.endPosition,
                )
            )
        }

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        // Check if this if statement has a brace open in it
        if (currentToken.token == Tokens.BRACES_OPEN) {
            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            // Parse the statement(s)
            val statementsResult = result.register(statements())
            if (result.hasError) return result

            val statementsIf = statementsResult as StatementsNode

            // Save that to the statements
            statements.add(statementsIf)

            if (currentToken.token != Tokens.BRACES_CLOSE) {
                return result.failure(
                    SyntaxError(
                        "Expected a close brace '}' after statements",
                        currentToken.startPosition,
                        currentToken.endPosition,
                    )
                )
            }

            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

        } else {
            // Parse the expression / statement
            val expressionResult = result.register(statement())
            if (result.hasError) return result

            val expression = expressionResult as Node

            // Save that to the statements
            statements.add(expression)

            // We're doing single line
            isSingleLine = true
        }

        val elifNodes = ArrayList<ElifNode>()

        //////////////////////////////////////////////////////////////
        // ELIF STATEMENT
        //////////////////////////////////////////////////////////////

        // Now check for elif(s)
        while (currentToken.token == Tokens.ELIF) {
            val elifNode = result.register(elifExpression())
            if (result.hasError) return result

            elifNodes.add(elifNode as ElifNode)
        }

        // Finally, check the else statement

        //////////////////////////////////////////////////////////////
        // ELSE STATEMENT
        //////////////////////////////////////////////////////////////

        var elseStatements: StatementsNode? = null

        // else is optional on multiline statement
        if (currentToken.token == Tokens.ELSE) {
            // Parse the else's statements
            val expressionResultElse = result.register(elseExpression())
            if (result.hasError) return result

            elseStatements = expressionResultElse as StatementsNode

            // whilst else is mandatory on single line if statement
        } else if (isSingleLine) {
            return result.failure(
                SyntaxError(
                    "Expected 'else'. An else block is required in an expression if",
                    currentToken.startPosition,
                    currentToken.endPosition,
                )
            )
        }

        // -----------------------------------------------------------
        // Done
        // -----------------------------------------------------------

        return result.success(
            IfNode(
                conditionExpression,                        // If's condition
                StatementsNode(statements.toTypedArray()),  // If's statements
                elifNodes.toTypedArray(),                   // Elif(s) condition & statements
                elseStatements,                             // Else's statements (if present)
                isSingleLine,                               // Is an expression
                startPosition,                              // Start position
                currentToken.endPosition                    // End Position
            )
        )
    }

    // elif-expression = ELIF PAREN_OPEN expression PAREN_CLOSE [[BRACES_OPEN statements BRACES_CLOSE] | statement]
    private fun elifExpression(): ParseResult {
        val result = ParseResult()
        val startPosition = currentToken.startPosition.copy()

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        if (currentToken.token != Tokens.PAREN_OPEN) {
            return result.failure(
                SyntaxError(
                    "Expected an open parentheses '(' after 'elif'",
                    currentToken.startPosition,
                    currentToken.endPosition,
                )
            )
        }

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        // Parse the condition
        val conditionExpressionResultElif = result.register(expression())
        if (result.hasError) return result

        val conditionExpressionElif = conditionExpressionResultElif as Node

        if (currentToken.token != Tokens.PAREN_CLOSE) {
            return result.failure(
                SyntaxError(
                    "Expected a close parentheses ')' after an expression",
                    currentToken.startPosition,
                    currentToken.endPosition,
                )
            )
        }

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        // Check if this elif statement has a brace open in it
        if (currentToken.token == Tokens.BRACES_OPEN) {
            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            // Parse the statement(s)
            val statementsResult = result.register(statements())
            if (result.hasError) return result

            val statements = statementsResult as StatementsNode

            if (currentToken.token != Tokens.BRACES_CLOSE) {
                return result.failure(
                    SyntaxError(
                        "Expected a close brace '}' after statements in elif",
                        currentToken.startPosition,
                        currentToken.endPosition,
                    )
                )
            }

            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            return result.success(
                ElifNode(
                    conditionExpressionElif,
                    statements,
                    startPosition,
                    currentToken.endPosition
                )
            )

        } else {
            // Parse the expression / statement
            val expressionResult = result.register(statement())
            if (result.hasError) return result

            val expression = expressionResult as Node

            return result.success(
                ElifNode(
                    conditionExpressionElif,
                    StatementsNode(arrayOf(expression)),
                    startPosition,
                    currentToken.endPosition
                )
            )
        }
    }

    // else-expression = ELSE [[BRACES_OPEN statements BRACES_CLOSE] | statement]
    private fun elseExpression(): ParseResult {
        val result = ParseResult()

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        if (currentToken.token == Tokens.BRACES_OPEN) {

            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            // Parse the statement(s)
            val statementsResult = result.register(statements())
            if (result.hasError) return result

            val statements = statementsResult as StatementsNode

            if (currentToken.token != Tokens.BRACES_CLOSE) {
                return result.failure(
                    SyntaxError(
                        "Expected a close brace '}' after statements in else",
                        currentToken.startPosition,
                        currentToken.endPosition,
                    )
                )
            }

            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            return result.success(statements)

        } else {
            // Parse the expression / statement
            val expressionResult = result.register(statement())
            if (result.hasError) return result

            val expression = expressionResult as Node

            return result.success(StatementsNode(arrayOf(expression)))
        }
    }

    // list-expression = BRACKET_OPEN [expression [COMMA expression]]* BRACKET_CLOSE
    private fun listExpression(): ParseResult {
        val items = ArrayList<Node>()
        val result = ParseResult()

        if (currentToken.token != Tokens.BRACKET_OPEN) {
            return result.failure(
                SyntaxError(
                    "Expected an open bracket '['",
                    currentToken.startPosition,
                    currentToken.endPosition
                )
            )
        }

        val startPosition = currentToken.startPosition.copy()

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        // Check if this is just an empty list
        if (currentToken.token == Tokens.BRACKET_CLOSE) {
            val bracketCloseTokenEndPos = currentToken.endPosition.copy()

            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            // Return an empty list
            return result.success(ListNode(startPosition, bracketCloseTokenEndPos))
        }

        // Parse expression(s)
        val firstExpressionResult = result.register(expression())
        if (result.hasError) return result

        items.add(firstExpressionResult as Node)

        while (currentToken.token == Tokens.COMMA) {
            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            // Parse the expression after the comma
            val expressionResult = result.register(expression())
            if (result.hasError) return result

            items.add(expressionResult as Node)
        }

        if (currentToken.token != Tokens.BRACKET_CLOSE) {
            return result.failure(
                SyntaxError(
                    "Expected a close bracket ']' after expression(s)",
                    currentToken.startPosition,
                    currentToken.endPosition,
                )
            )
        }

        val bracketCloseEndPos = currentToken.endPosition.copy()

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        // Alright we're done parsing
        return result.success(
            ListNode(
                startPosition,
                bracketCloseEndPos,
                items
            )
        )
    }

    // atom = INT_LITERAL | FLOAT_LITERAL | IDENTIFIER | STRING_LITERAL | [PAREN_OPEN expression* PAREN_CLOSE] | [TRUE|FALSE] | list-expression | if-expression | for-expression | while-expression
    private fun atom(): ParseResult {
        val result = ParseResult()
        val oldToken = currentToken.copy()

        when (oldToken.token) {

            // Check if the current token is an int
            Tokens.INT_LITERAL -> {
                result.registerAdvancement()
                advance()

                return result.success(IntegerNode(oldToken))
            }

            // Check if the current token is a float
            Tokens.FLOAT_LITERAL -> {
                result.registerAdvancement()
                advance()

                return result.success(FloatNode(oldToken))
            }

            // Check if the current token is an identifier (variable)
            Tokens.IDENTIFIER -> {
                result.registerAdvancement()
                advance()

                return result.success(VarAccessNode(oldToken))
            }

            Tokens.STRING_LITERAL -> {
                result.registerAdvancement()
                advance()

                return result.success(StringNode(oldToken))
            }

            // Check if the current token is an open parentheses
            Tokens.PAREN_OPEN -> {


                // this may be a lambda (ParameterList) {}

                val currentTokenIndex = indexToken

                // skip until )
                while (currentToken.token != Tokens.PAREN_CLOSE) {
                    result.registerAdvancement()
                    advance()

                    if (currentToken.token == Tokens.EOF) {
                        return result.failure(
                            SyntaxError(
                                "Expected a close parentheses ')'",
                                currentToken.startPosition,
                                currentToken.endPosition,
                            )
                        )
                    }
                }

                result.registerAdvancement()
                advance()

                // skip until new lines
                while (currentToken.token == Tokens.NEWLINE) {
                    result.registerAdvancement()
                    advance()
                }

                // check if the next token is a BRACES_OPEN
                if (currentToken.token == Tokens.BRACES_OPEN) {
                    // this is a lambda

                    // go back
                    reverse(indexToken - currentTokenIndex)

                    val lambdaResult = result.register(lambda())
                    if (result.hasError) return result

                    return result.success(lambdaResult as Node)
                }

                // its not a lambda, go back
                reverse(indexToken - currentTokenIndex)

                result.registerAdvancement()
                advance()



                val expression = result.register(expression())

                if (result.hasError) return result

                // Check if the parentheses is closed
                return if (currentToken.token == Tokens.PAREN_CLOSE) {
                    result.registerAdvancement()
                    advance()
                    result.success(expression as Node)
                } else {
                    result.failure(
                        SyntaxError(
                            "Expected an integer or a float literal",
                            currentToken.startPosition,
                            currentToken.endPosition,
                        )
                    )
                }
            }

            // Check if the current token is a boolean literal (true / false)
            Tokens.TRUE, Tokens.FALSE -> {
                result.registerAdvancement()
                advance()

                return result.success(BooleanNode(oldToken))
            }

            Tokens.BRACKET_OPEN -> {
                val listResult = result.register(listExpression())
                if (result.hasError) return result

                return result.success(listResult as Node)
            }

            // Check if this is an if expression
            Tokens.IF -> {
                val ifResult = result.register(ifExpression())
                if (result.hasError) return result

                return result.success(ifResult as Node)
            }

            // Check if this is an for loop
            Tokens.FOR -> {
                val forResult = result.register(forExpression())
                if (result.hasError) return result

                return result.success(forResult as Node)
            }

            // Check if this is a while statement
            Tokens.WHILE -> {
                val whileResult = result.register(whileExpression())
                if (result.hasError) return result

                return result.success(whileResult as Node)
            }

            // Check if this is a function definition
            Tokens.FUN -> {
                val funcDefResult = result.register(funcDefinition())
                if (result.hasError) return result

                return result.success(funcDefResult as Node)
            }

            Tokens.COMPOSABLE -> {
                advance()

                val funcDefResult = result.register(funcDefinition())
                if (result.hasError) return result

                val funcDefNode = (funcDefResult as FunctionDefinitionNode)

                // we append the $composer: Composer, and $changed: Int to the parameters

                val newParameters = funcDefNode.parameters.parameters.toMutableList()
                newParameters.add(ParameterNode("\$composer", null, oldToken.startPosition, oldToken.endPosition))
                newParameters.add(ParameterNode("\$changed", null, oldToken.startPosition, oldToken.endPosition))

                val composeFunNode = ComposeFunctionDefinitionNode(
                    funcDefNode.functionName,
                    ParameterListNode(newParameters, funcDefNode.parameters.startPosition, funcDefNode.parameters.endPosition),
                    funcDefNode.statements,
                    funcDefNode.startPosition,
                    funcDefNode.endPosition,
                )

                return result.success(composeFunNode)
            }

            Tokens.NULL -> {
                result.registerAdvancement()
                advance()

                return result.success(NullNode(oldToken.startPosition, oldToken.endPosition))
            }

            else -> {
                return result.failure(
                    SyntaxError(
                        "Expected an integer literal, float literal, identifier, string literal, 'if', 'for', 'true', 'false', '+', '-', or '('",
                        oldToken.startPosition,
                        oldToken.endPosition,
                    )
                )
            }
        }
    }

    // atom [PAREN_OPEN IDENTIFIER [COMMA IDENTIFIER]* PAREN_CLOSE]
    private fun funcCall(): ParseResult {
        val result = ParseResult()
        val startPosition = currentToken.startPosition.copy()

        val incDecResult = result.register(atom()) as Node?
        if (result.hasError) return result

        val incDecNode = incDecResult as Node

        // Check if this is a function call
        if (currentToken.token != Tokens.PAREN_OPEN) {
            // Nope it's not, let's just return
            return result.success(incDecNode)

        } else {
            // Yep it is a function call, let's do stuff

            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            // skip every newlines
            while (currentToken.token == Tokens.NEWLINE) {
                result.registerAdvancement()
                advance()
            }

            // Check if this is just a plain function call without any arguments
            if (currentToken.token == Tokens.PAREN_CLOSE) {
                // ===========================================================
                result.registerAdvancement()
                advance()
                // ===========================================================

                return result.success(
                    FunctionCallNode(
                        incDecNode,
                        emptyArray(),
                        startPosition,
                        currentToken.endPosition
                    )
                )
            }

            val arguments = ArrayList<Node>()

            // Nope, we have arguments
            val firstArgumentResult = result.register(expression()) as Node?
            if (result.hasError) return result

            arguments.add(firstArgumentResult as Node)

            // skip every newlines
            while (currentToken.token == Tokens.NEWLINE) {
                result.registerAdvancement()
                advance()
            }

            // Check if we have more arguments
            while (currentToken.token == Tokens.COMMA) {

                // ===========================================================
                result.registerAdvancement()
                advance()
                // ===========================================================

                while (currentToken.token == Tokens.NEWLINE) {
                    result.registerAdvancement()
                    advance()
                }

                val argumentResult = result.register(expression()) as Node?
                if (result.hasError) return result

                arguments.add(argumentResult as Node)

                // skip every newlines
                while (currentToken.token == Tokens.NEWLINE) {
                    result.registerAdvancement()
                    advance()
                }
            }

            while (currentToken.token == Tokens.NEWLINE) {
                result.registerAdvancement()
                advance()
            }

            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            // Ok, done, return
            return result.success(
                FunctionCallNode(
                    incDecNode,
                    arguments.toTypedArray(),
                    startPosition,
                    currentToken.endPosition
                )
            )
        }
    }

    // index = func-call [BRACKET_OPEN expression BRACKET_CLOSE]
    private fun index(): ParseResult {
        val result = ParseResult()
        val leftNodeResult = result.register(funcCall()) as Node?

        if (result.hasError) return result

        val leftNode = leftNodeResult as Node

        // Check if we have the bracket open token to do index
        if (currentToken.token == Tokens.BRACKET_OPEN) {

            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            val expressionResult = result.register(expression()) as Node?

            if (result.hasError) return result

            val expression = expressionResult as Node

            if (currentToken.token != Tokens.BRACKET_CLOSE) {
                return result.failure(
                    SyntaxError(
                        "Expected a close bracket ']' after an expression",
                        currentToken.startPosition,
                        currentToken.endPosition,
                    )
                )
            }

            val bracketCloseTokenEndPos = currentToken.endPosition.copy()

            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            return result.success(
                IndexNode(
                    leftNode,
                    expression,
                    bracketCloseTokenEndPos
                )
            )
        }

        return result.success(leftNode)
    }


    // increment-decrement = index [DOUBLE_PLUS | DOUBLE_MINUS]
    private fun incrementDecrement(): ParseResult {
        val result = ParseResult()

        val atomNodeResult = result.register(index()) as Node?
        if (result.hasError) return result

        when (currentToken.token) {
            // Check if the next token is a double plus or a double minus
            Tokens.DOUBLE_PLUS -> {
                val doublePlusToken = currentToken.copy()

                // ===========================================================
                result.registerAdvancement()
                advance()
                // ===========================================================

                return result.success(IncrementOrDecrementNode(doublePlusToken, atomNodeResult!!))
            }

            Tokens.DOUBLE_MINUS -> {
                val doubleMinusToken = currentToken.copy()

                // ===========================================================
                result.registerAdvancement()
                advance()
                // ===========================================================

                return result.success(IncrementOrDecrementNode(doubleMinusToken, atomNodeResult!!))
            }

            // Nope, just return
            else -> return result.success(atomNodeResult!!)
        }
    }

    // power = increment-decrement [POW factor]*
    private fun power(): ParseResult {
        val result = ParseResult()
        val leftNodeResult = result.register(incrementDecrement()) as Node?

        if (result.hasError) return result

        var leftNode = leftNodeResult as Node

        while (currentToken.token == Tokens.POW) {
            val operatorToken = currentToken.copy()

            result.registerAdvancement()
            advance()

            val rightNode = result.register(factor()) as Node?

            if (result.hasError) return result

            leftNode = BinOpNode(leftNode, operatorToken, rightNode!!)
        }

        return result.success(leftNode)
    }

    private val unaryTokens = arrayOf(Tokens.PLUS, Tokens.MINUS)

    // factor = [[PLUS|MINUS] factor] | power
    private fun factor(): ParseResult {
        val result = ParseResult()
        val oldToken = currentToken.copy()

        // Check if the current token contains a unary operator (+ and -)
        if (unaryTokens.contains(oldToken.token)) {
            result.registerAdvancement()
            advance()

            val factor = result.register(factor())

            if (result.hasError) return result

            return result.success(UnaryOpNode(oldToken, factor as Node))
        } else {
            return power()
        }
    }

    private val termOperators = arrayOf(Tokens.MUL, Tokens.DIV)

    // term = factor [[MUL|DIV] factor]*
    private fun term(): ParseResult {
        val result = ParseResult()
        val leftNodeResult = result.register(factor()) as Node?

        if (result.hasError) return result

        var leftNode = leftNodeResult as Node

        while (termOperators.contains(currentToken.token)) {
            val operatorToken = currentToken.copy()

            result.registerAdvancement()
            advance()

            val rightNode = result.register(factor()) as Node?

            if (result.hasError) return result

            leftNode = BinOpNode(leftNode, operatorToken, rightNode!!)
        }

        return result.success(leftNode)
    }

    private val arithmeticOperators = arrayOf(Tokens.PLUS, Tokens.MINUS)

    // arithmetic-expression = term [[PLUS|MINUS] term]*
    private fun arithmeticExpression(): ParseResult {
        val result = ParseResult()
        val leftNodeResult = result.register(term()) as Node?

        if (result.hasError) return result

        var leftNode = leftNodeResult as Node

        while (arithmeticOperators.contains(currentToken.token)) {
            // Get the operator and the next term
            val operatorToken = currentToken.copy()

            result.registerAdvancement()
            advance()

            val rightNode = result.register(expression()) as Node?

            if (result.hasError) return result

            leftNode = BinOpNode(leftNode, operatorToken, rightNode!!)
        }

        return result.success(leftNode)
    }

    private val comparisonOperators = arrayOf(
        Tokens.DOUBLE_EQUALS,
        Tokens.NOT_EQUAL,
        Tokens.GREATER_THAN,
        Tokens.LESSER_THAN,
        Tokens.GREATER_OR_EQUAL_THAN,
        Tokens.LESSER_OR_EQUAL_THAN
    )

    // comparison-expression = NOT comparison-expression | arithmetic-expression [[comparison operators] arithmetic-expression]*
    private fun comparisonExpression(): ParseResult {
        val result = ParseResult()

        // Check if the current token is the NOT token
        if (currentToken.token == Tokens.NOT) {
            val notToken = currentToken.copy()

            result.registerAdvancement()
            advance()

            // then do the comparison expression
            val comparisonExpression = result.register(comparisonExpression()) as Node?

            if (result.hasError) return result

            return result.success(UnaryOpNode(notToken, comparisonExpression as Node))

        } else {
            // if no NOT token, let's do an arithmetic expression, very similar to term and factor
            val arithmeticExpressionResult = result.register(arithmeticExpression()) as Node?

            if (result.hasError) return result

            var leftNode = arithmeticExpressionResult as Node

            while (comparisonOperators.contains(currentToken.token)) {
                val operatorToken = currentToken.copy()

                result.registerAdvancement()
                advance()

                val rightNode = result.register(arithmeticExpression()) as Node?

                if (result.hasError) return result

                leftNode = BinOpNode(leftNode, operatorToken, rightNode!!)
            }

            return result.success(leftNode)
        }
    }

    private val equalOperations = arrayOf(Tokens.PLUS_EQUAL, Tokens.MINUS_EQUAL, Tokens.MUL_EQUAL, Tokens.DIV_EQUAL)

    // expression = VAR IDENTIFIER [EQUAL expression]? | IDENTIFIER EQUAL expression | IDENTIFIER [PLUS_EQUAL | MINUS_EQUAL | MUL_EQUAL | DIV_EQUAL] | comparison-expression [[AND|OR] comparison-expression]*
    private fun expression(): ParseResult {
        val result = ParseResult()

        // Check if this the var token
        if (currentToken.token == Tokens.VAR) {
            val varToken = currentToken.copy()

            result.registerAdvancement()
            advance()

            val identifierToken = currentToken.copy()

            // Check if the next token is an identifier
            if (identifierToken.token != Tokens.IDENTIFIER) {
                return result.failure(
                    SyntaxError(
                        "Expected an identifier",
                        currentToken.startPosition,
                        currentToken.endPosition
                    )
                )
            }

            result.registerAdvancement()
            advance()

            // Check if this variable is initialized early
            if (currentToken.token != Tokens.EQUAL) {
                // Alright, we're going to declare the variable but without initializing it
                return result.success(
                    VarDeclarationNode(
                        identifierToken.value!!,
                        null,
                        varToken.startPosition,
                        currentToken.endPosition.copy()
                    )
                )

            } else {
                // Nope, it's an equal sign, means we need to initialize the variable
                result.registerAdvancement()
                advance()

                // Ok, now we're setup, let's parse the expression
                val expressionResult = result.register(expression()) as Node?
                if (result.hasError) return result

                val expression = expressionResult as Node

                // return a VarDeclarationNode
                return result.success(
                    VarDeclarationNode(
                        identifierToken.value!!,
                        expression,
                        varToken.startPosition,
                        currentToken.endPosition.copy()
                    )
                )
            }

        } else if (currentToken.token == Tokens.IDENTIFIER) {
            val identifierToken = currentToken.copy()

            // Peek the next token
            advance()

            // Check if this is a variable assignment
            if (currentToken.token == Tokens.EQUAL) {
                // Yes this is a variable assignment
                // Don't forget to register the advancement we did earlier
                result.registerAdvancement()

                // pass over the equal token
                // ===========================================================
                advance()
                result.registerAdvancement()
                // ===========================================================

                // then parse the value as an expression
                val variableValueResult = result.register(expression())
                if (result.hasError) return result

                val variableValue = variableValueResult as Node

                return result.success(
                    VarAssignNode(
                        identifierToken.value!!,
                        variableValue,
                        identifierToken.startPosition
                    )
                )

                // Check if this is one of the equal operators
            } else if (equalOperations.contains(currentToken.token)) {
                val startPosition = currentToken.startPosition.copy()

                // Alright then register the advancement
                result.registerAdvancement()

                // Parse the equal operation to default operations like PLUS, MINUS, etc
                val equalOperation: Token = when (currentToken.token) {
                    Tokens.PLUS_EQUAL -> currentToken.copy(token = Tokens.PLUS)
                    Tokens.MINUS_EQUAL -> currentToken.copy(token = Tokens.MINUS)
                    Tokens.MUL_EQUAL -> currentToken.copy(token = Tokens.MUL)
                    Tokens.DIV_EQUAL -> currentToken.copy(token = Tokens.DIV)

                    else -> throw RuntimeException("Unknown equal operator ${currentToken.token.name}")
                }

                // ===========================================================
                advance()
                result.registerAdvancement()
                // ===========================================================

                // And parse the expression next to it
                val valueResult = result.register(expression())
                if (result.hasError) return result

                val value = valueResult as Node

                // Return nodes equal to "identifierToken = identifierToken OPERATOR value"
                return result.success(
                    VarAssignNode(
                        identifierToken.value!!,
                        BinOpNode(
                            VarAccessNode(identifierToken),
                            equalOperation,
                            value
                        ),
                        startPosition
                    )
                )
            }

            // Not a variable assignment, go back and do a comparison expression instead then
            reverse(1)
        }

        // do a comparison expression, very similar to term and factor
        val comparisonExpressionResult = result.register(comparisonExpression()) as Node?

        if (result.hasError) return result

        var leftNode = comparisonExpressionResult as Node

        while (currentToken.token == Tokens.AND || currentToken.token == Tokens.OR) {
            val operatorToken = currentToken.copy()

            result.registerAdvancement()
            advance()

            val rightNode = result.register(comparisonExpression()) as Node?

            if (result.hasError) return result

            leftNode = BinOpNode(leftNode, operatorToken, rightNode!!)
        }

        return result.success(leftNode)
    }

    // RETURN expression? | CONTINUE | BREAK | expression
    private fun statement(): ParseResult {
        val result = ParseResult()
        val startPosition = currentToken.startPosition.copy()

        // Check if the current token is either RETURN, CONTINUE, or BREAK
        when (currentToken.token) {
            Tokens.RETURN -> {
                // ===========================================================
                advance()
                result.registerAdvancement()
                // ===========================================================

                // Check if the next is an expression
                val expression = result.tryRegister(expression())
                if (expression == null) {
                    // no the next is not an expression, then just reverse
                    reverse(result.reverseCount)
                }

                return result.success(
                    ReturnNode(expression as Node?, startPosition, currentToken.endPosition)
                )
            }

            Tokens.CONTINUE -> {
                // ===========================================================
                advance()
                result.registerAdvancement()
                // ===========================================================

                return result.success(ContinueNode(startPosition, currentToken.endPosition))
            }

            Tokens.BREAK -> {
                // ===========================================================
                advance()
                result.registerAdvancement()
                // ===========================================================

                return result.success(BreakNode(startPosition, currentToken.endPosition))
            }

            Tokens.IDENTIFIER -> {

                var advanceCount = 0

                advance()
                advanceCount += 1

                // skip newlines
                while (currentToken.token == Tokens.NEWLINE) {
                    result.registerAdvancement()
                    advance()
                    advanceCount += 1
                }

                if (currentToken.token == Tokens.PAREN_OPEN) {
                    reverse(advanceCount)
                    val expression = result.register(funcCall()) as Node?
                    if (result.hasError) return result
                    return result.success(expression!!)
                } else {
                    reverse(advanceCount)

                    val expression = result.register(expression())
                    if (result.hasError) return result

                    return result.success(expression as Node)
                }
            }

            else -> {
                // not any of these statements, just do an expression instead then
                val expression = result.register(expression())
                if (result.hasError) return result

                return result.success(expression as Node)
            }
        }
    }

    // statements = NEWLINE* statement [NEWLINE+ expression]* NEWLINE*
    private fun statements(): ParseResult {
        val result = ParseResult()
        val statements = ArrayList<Node>()

        while (currentToken.token == Tokens.NEWLINE) {
            result.registerAdvancement()
            advance()
        }

        val firstStatement = result.register(statement())
        if (result.hasError) return result

        statements.add(firstStatement as Node)

        var moreStatements = true

        while (true) {
            var newlineCount = 0

            while (currentToken.token == Tokens.NEWLINE) {
                result.registerAdvancement()
                advance()
                newlineCount += 1
            }

            if (newlineCount == 0) moreStatements = false

            if (!moreStatements) break

            val statement = result.tryRegister(statement())

            if (statement == null) {
                reverse(result.reverseCount)
                moreStatements = false
                continue
            }

            statements.add(statement as Node)
        }

        return result.success(StatementsNode(statements.toTypedArray()))
    }

    fun lambda(): ParseResult {
        val result = ParseResult()
        val startPosition = currentToken.startPosition.copy()

        val parameterListResult = parameterList()
        if (parameterListResult.hasError) return parameterListResult

        val parameterList = parameterListResult.node as ParameterListNode

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        // { statements }

        // bracket open
        if (currentToken.token != Tokens.BRACES_OPEN) {
            return result.failure(
                SyntaxError(
                    "Expected an open brace '{' after lambda",
                    currentToken.startPosition,
                    currentToken.endPosition
                )
            )
        }

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        // empty lambda
        if (currentToken.token == Tokens.BRACES_CLOSE) {
            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            return result.success(
                LambdaNode(
                    parameterList,
                    StatementsNode(emptyArray()),
                    startPosition,
                    currentToken.endPosition
                )
            )
        }

        // skip newlines
        while (currentToken.token == Tokens.NEWLINE) {
            result.registerAdvancement()
            advance()
        }

        // is a bracket?
        if (currentToken.token == Tokens.BRACES_CLOSE) {
            // ===========================================================
            result.registerAdvancement()
            advance()
            // ===========================================================

            return result.success(
                LambdaNode(
                    parameterList,
                    StatementsNode(emptyArray()),
                    startPosition,
                    currentToken.endPosition
                )
            )
        }

        val statementsResult = statements()
        if (statementsResult.hasError) return statementsResult

        // newlines
        while (currentToken.token == Tokens.NEWLINE) {
            result.registerAdvancement()
            advance()
        }

        // bracket close
        if (currentToken.token != Tokens.BRACES_CLOSE) {
            return result.failure(
                SyntaxError(
                    "Expected a close brace '}' after lambda",
                    currentToken.startPosition,
                    currentToken.endPosition
                )
            )
        }

        // ===========================================================
        result.registerAdvancement()
        advance()
        // ===========================================================

        while (currentToken.token == Tokens.NEWLINE) {
            result.registerAdvancement()
            advance()
        }



        return result.success(
            LambdaNode(
                parameterList,
                statementsResult.node as StatementsNode,
                startPosition,
                currentToken.endPosition
            )
        )
    }
}
